{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup do Projeto Backend com Spring Boot 3.0 e Clean Architecture",
        "description": "Configurar estrutura inicial do backend seguindo Clean Architecture com dependências Maven, PostgreSQL, Spring Security e HikariCP",
        "details": "Criar estrutura de pastas: domain/application/infrastructure/presentation/config. Configurar pom.xml com Java 17, Spring Boot 3.0+, Spring Security, Hibernate/JPA, HikariCP. Implementar Application.java principal com @SpringBootApplication. Configurar application.yml com PostgreSQL datasource, JWT secret e CORS para frontend React. Implementar HealthCheck endpoint /actuator/health.",
        "testStrategy": "Testar inicialização do Spring Context com @SpringBootTest. Verificar conexão PostgreSQL com Testcontainers. Executar testes unitários de configuração com @TestConfiguration. Validar endpoints /health e /actuator/health retornando 200 OK.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-14T00:42:20.802Z"
      },
      {
        "id": 2,
        "title": "Implementar Entidade User e Repositório com Spring Data JPA",
        "description": "Criar entidade User no domínio com campos email, password_hash, nome, ativo e timestamps. Implementar UserRepository com queries customizadas",
        "details": "Domain: User.java com @Entity, @Table(name=\"users\"), campos id(UUID), email(unique), password_hash(BCrypt), nome, ativo(boolean), criado_em/atualizado_em. Application: UserDTO, CreateUserUseCase. Infrastructure: UserRepository extends JpaRepository<User, UUID> com @Query para findByEmail. Infrastructure: UserJpaRepositoryImpl. Configurar BCryptPasswordEncoder como @Bean.",
        "testStrategy": "Testes unitários para User entity validation com @Valid. Testes de repositório com Testcontainers PostgreSQL. Verificar hash de senha com BCrypt. Testar findByEmail com usuário existente/não existente.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-14T00:42:20.821Z"
      },
      {
        "id": 3,
        "title": "Sistema de Autenticação JWT com Spring Security",
        "description": "Implementar endpoints de autenticação: register, login, refresh, logout com JWT tokens e BCrypt password hashing",
        "details": "Presentation: AuthController com POST /api/v1/auth/register, /login, /refresh, /logout. Application: AuthService com JWT generation (jjwt library), token validation. Config: JwtAuthenticationFilter extends OncePerRequestFilter, SecurityConfig com .httpBasic().disable().jwt(). Infrastructure: UserDetailsServiceImpl. Tokens com expiração 15min access/7days refresh. Logout invalida refresh token.",
        "testStrategy": "Testes de integração com @WebMvcTest e MockMvc. Testar fluxos register->login->refresh->logout. Validar tokens JWT com jwt.io. Verificar 401 Unauthorized sem token válido. Testar SQL injection prevention.",
        "priority": "high",
        "dependencies": [
          "1",
          "2"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-14T00:42:20.842Z"
      },
      {
        "id": 4,
        "title": "CRUD de Projetos com Estrutura Kanban Automática",
        "description": "Implementar entidade Project e endpoints REST para criar/listar/atualizar projetos com criação automática de colunas Kanban",
        "details": "Entities: Project (id, nome, descricao, owner_id, cliente, tipo enum{RESIDENCIAL,COMERCIAL,REFORMA,OUTRO}, status, datas), ProjectPhase (TODO,IN_PROGRESS,REVIEW,DONE). Repositories para ambas. UseCases: CreateProjectUseCase cria projeto + 4 fases padrão. Controller: GET/POST/PUT/DELETE /api/v1/projects. Validação: nome obrigatório, data_fim > data_inicio.",
        "testStrategy": "Testes completos CRUD com Postman collection. Verificar criação automática de 4 fases Kanban. Testar validações de negócio (datas, campos obrigatórios). Mock autenticação JWT. Verificar auditoria em audit_log.",
        "priority": "high",
        "dependencies": [
          "1",
          "2",
          "3"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-14T00:42:20.865Z"
      },
      {
        "id": 5,
        "title": "Sistema RBAC e Membros de Projeto",
        "description": "Implementar RBAC com roles ADMIN,PROJECT_OWNER,MANAGER,ARCHITECT,VIEWER,CLIENT e associação de membros aos projetos",
        "details": "Entity: ProjectMember (project_id, user_id, role enum, permissoes JSONB). Service: ProjectMemberService com métodos addMember, removeMember, getPermissions. Interceptor JWT para verificar role por projeto. Endpoint: POST/GET /api/v1/projects/{id}/members. Roles hierárquicas: ADMIN > PROJECT_OWNER > MANAGER > ARCHITECT > VIEWER > CLIENT.",
        "testStrategy": "Testes de autorização com diferentes roles. Verificar que apenas PROJECT_OWNER+ pode adicionar membros. Testar herança de permissões. Scenarios: admin adiciona todos, viewer só lê.",
        "priority": "high",
        "dependencies": [
          "1",
          "2",
          "3",
          "4"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar Entity ProjectMember e Role Enum",
            "description": "Criar a entidade ProjectMember com campos project_id, user_id, role (enum), permissoes JSONB e definir enum Role com ADMIN,PROJECT_OWNER,MANAGER,ARCHITECT,VIEWER,CLIENT.",
            "dependencies": [],
            "details": "Adicionar @Entity, @Table, @Enumerated(EnumType.STRING) para role, @Column(columnDefinition=\"jsonb\") para permissoes. Incluir relacionamentos @ManyToOne com Project e User. Gerar migrations com Flyway/Liquibase.",
            "status": "done",
            "testStrategy": "Testar serialização JSONB de permissões, validação enum role, constraints unique(project_id,user_id). Verificar herança hierárquica ADMIN > PROJECT_OWNER."
          },
          {
            "id": 2,
            "title": "Desenvolver ProjectMemberService com métodos CRUD",
            "description": "Implementar ProjectMemberService com addMember, removeMember, getPermissions, considerando hierarquia de roles e validações de autorização básica.",
            "dependencies": [
              1
            ],
            "details": "Método addMember verifica se caller tem role >= PROJECT_OWNER no projeto. getPermissions retorna JSONB com permissões efetivas + herança. Injetar ProjectRepository e UserRepository. Tratar exceções AccessDeniedException.",
            "status": "done",
            "testStrategy": "Testes unitários com Mockito: addMember por ADMIN sucesso, VIEWER falha 403. Verificar herança permissões MANAGER herda de PROJECT_OWNER. Testar getPermissions retorna JSON correto."
          },
          {
            "id": 3,
            "title": "Criar Controller e Endpoints para Gerenciamento de Membros",
            "description": "Implementar REST endpoints POST/GET /api/v1/projects/{id}/members no ProjectMemberController com validação de input e integração com service.",
            "dependencies": [
              2
            ],
            "details": "POST recebe {userId, role}, valida role enum. GET retorna lista membros com roles e permissões. Usar @RestController, @Validated, ResponseEntity. Documentar com OpenAPI/Swagger.",
            "status": "done",
            "testStrategy": "Testes @WebMvcTest com MockMvc: POST 201 com token PROJECT_OWNER, 403 com VIEWER. GET 200 lista completa para ADMIN. Validar JSON response schema."
          },
          {
            "id": 4,
            "title": "Implementar JWT Interceptor para Verificação de Role por Projeto",
            "description": "Criar interceptor JWT que extrai user_id do token, consulta ProjectMember para role no projeto específico e verifica hierarquia de permissões.",
            "dependencies": [
              2,
              3
            ],
            "details": "Estender HandlerInterceptorAdapter ou OncePerRequestFilter. Extrair claims JWT com JwtDecoder. Consultar service.getUserRoleInProject(projectId, userId). Definir roles ordenadas em enum com compareTo(). Aplicar em endpoints /projects/{id}/**.",
            "status": "done",
            "testStrategy": "Testes integração: ADMIN acessa tudo, CLIENT só GET falha em POST. Simular tokens diferentes roles. Verificar 403 Unauthorized sem role válida no projeto. Performance <50ms consulta."
          }
        ]
      },
      {
        "id": 6,
        "title": "Gerenciamento de Tarefas com Estrutura JSON Completa",
        "description": "Implementar entidade Task com todos os campos especificados (prioridade, datas, tags, checklist, historico) e endpoints CRUD",
        "details": "Entity Task: todos campos do JSON schema (id uuid, titulo, descricao, projeto_id, responsavel_id, status enum, prioridade enum{HIGH,MEDIUM,LOW}, datas, tags array, anexos/ comentarios/ checklist/ historico JSONB arrays). Endpoints: GET/POST /api/v1/projects/{id}/tasks, PATCH /tasks/{id}/status. Validações JSR303.",
        "testStrategy": "Testes completos CRUD tarefas. Verificar constraints JSONB fields. Testar filtros por status/prioridade/responsavel. Performance: 1000 tarefas paginadas.",
        "priority": "high",
        "dependencies": [
          "1",
          "2",
          "3",
          "4",
          "5"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Update Task Entity with New Fields and JSONB Arrays",
            "description": "Extend existing Task entity to include priority enum, dueDate, tags array, and JSONB fields for attachments, comments, checklist, historico.",
            "dependencies": [],
            "details": "Add @Enumerated Priority {HIGH,MEDIUM,LOW}, @Temporal/LocalDate dueDate, @ElementCollection String tags, @Type(JsonBinaryType.class) List<Attachment> anexos, List<Comment> comentarios, List<ChecklistItem> checklist, List<HistoricoItem> historico. Include projeto_id, responsavel_id relations. Add JSR303 validations @NotNull, @Size.",
            "status": "done",
            "testStrategy": "Unit tests for entity validation with @Valid. Verify JSONB serialization/deserialization with Jackson. Test priority enum constraints and tag uniqueness.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create and Update Task DTOs for Full JSON Schema",
            "description": "Implement TaskDTO, CreateTaskDTO, UpdateTaskDTO including all new fields with validation annotations.",
            "dependencies": [
              1
            ],
            "details": "TaskDTO maps all entity fields. CreateTaskDTO excludes id/historico, requires titulo/descricao/projeto_id. UpdateTaskDTO @NotNull id, optional fields. Use MapStruct for entity-DTO mapping. Add @Valid groups for partial updates.",
            "status": "done",
            "testStrategy": "Test DTO validation with @Valid. Verify MapStruct mappings bidirectional. Test JSON serialization with new fields.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement TaskService with CRUD Logic and New Field Handling",
            "description": "Create TaskService methods for create/read/update/delete tasks, handling priority, tags, dueDate, and JSONB arrays.",
            "dependencies": [
              1,
              2
            ],
            "details": "Methods: createTask(CreateTaskDTO), getTasksByProject(UUID projectId, filters), updateTaskStatus(UUID id, Status status), updateTask(UUID id, UpdateTaskDTO). Auto-populate historico on updates. Validate responsavel_id permissions via ProjectMemberService. Use TaskRepository custom queries.",
            "status": "done",
            "testStrategy": "Integration tests with H2/Testcontainers. Verify historico auto-updates. Test filters by status/priority/responsavel. Mock ProjectMemberService.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Develop TaskController with Endpoints and JSR303 Validation",
            "description": "Implement REST controller for GET/POST /api/v1/projects/{id}/tasks and PATCH /tasks/{id}/status with full validation.",
            "dependencies": [
              2,
              3
            ],
            "details": "Use @RestController, @Validated. GET supports pagination/filters ?status= &priority= &responsavelId=. POST @RequestBody @Valid CreateTaskDTO. PATCH @PathVariable UUID id, @RequestBody UpdateStatusDTO. JWT auth interceptor for project access. Return TaskDTO.",
            "status": "done",
            "testStrategy": "Controller tests with MockMvc. Test 200/400/401/403/404 scenarios. Verify JSR303 rejects invalid priority/tags. Pagination with 1000 tasks.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Extend TaskRepository and Add JSONB Query Support",
            "description": "Update JpaRepository<Task, UUID> with custom queries for filtering by new fields and JSONB search capabilities.",
            "dependencies": [
              1
            ],
            "details": "Add @Query methods: findByProjectIdAndStatus(UUID projectId, Status status), findByPriority(Priority priority), fullTextSearchOnChecklist(String term), countByProjectId(UUID projectId). Support pagination with Pageable. JSONB queries using @Query native PostgreSQL.",
            "status": "done",
            "testStrategy": "Repository slice tests with Testcontainers PostgreSQL. Verify JSONB queries on checklist/historico. Performance: query 1000 tasks <500ms. Test pagination/sort.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 7,
        "title": "Setup Frontend React 18 com Vite, Tailwind e Radix UI",
        "description": "Configurar projeto React com Vite, TailwindCSS, Radix UI components, dnd-kit e roteamento React Router",
        "details": "npx create-vite@latest archflow-frontend --template react-ts. Instalar: @radix-ui/react-*, @dnd-kit/core @dnd-kit/sortable, tailwindcss postcss autoprefixer, lucide-react icons, react-router-dom. Configurar tailwind.config.js com Radix classes. Criar layout base com Sidebar + Header + Main. Implementar rotas: /login, /dashboard, /projects/:id.",
        "testStrategy": "Testar build production: npm run build && npm run preview. Verificar bundle size <200KB gzipped. Testes com Vitest + React Testing Library para componentes base. Lighthouse score >90.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-14T00:42:20.883Z"
      },
      {
        "id": 8,
        "title": "Implementar Quadro Kanban com Drag & Drop e WebSockets",
        "description": "Criar componente KanbanBoard com dnd-kit, colunas dinâmicas e sincronização real-time via Socket.io",
        "details": "Components: KanbanBoard.tsx (DndContext), KanbanColumn.tsx (Droppable), TaskCard.tsx (Draggable). Integrar Socket.io-client para escutar 'taskMoved' events. API calls com axios + JWT interceptor. Estados: useReducer para tasks por coluna. Colunas: TODO, IN_PROGRESS, UNDER_REVIEW, DONE. Feedback visual durante drag.",
        "testStrategy": "Testes E2E com Playwright: drag task TODO->IN_PROGRESS, verificar WebSocket update em outra aba. Testes unitários dnd-kit interactions. Performance: 100 tasks smooth dragging.",
        "priority": "high",
        "dependencies": [
          "7"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-14T00:42:20.911Z"
      },
      {
        "id": 9,
        "title": "Sistema de Comentários, @Mentions e Upload de Anexos",
        "description": "Implementar comentários rich text com @mentions, notificações e upload para GCP Cloud Storage",
        "details": "Backend: Comment entity, POST /tasks/{id}/comments, parse @mentions para notificações. Frontend: CommentEditor com TipTap/ProseMirror, @mention autocomplete de membros projeto. Upload: GCP Storage signed URLs. WebSocket para new_comment events. Preview inline imagens/PDFs.",
        "testStrategy": "Testar fluxo: comment com @user -> notificação -> usuário abre tarefa vê comentário. Upload 50MB arquivo sucesso. @mention parse correto. XSS prevention test.",
        "priority": "medium",
        "dependencies": [
          "1",
          "2",
          "3",
          "4",
          "5",
          "6",
          "7",
          "8"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar Entidade Comment e Backend API",
            "description": "Criar entidade Comment com campos rich_text, task_id, user_id, created_at e implementar POST /tasks/{id}/comments endpoint",
            "dependencies": [],
            "details": "Entity: @Entity Comment {id UUID, taskId UUID, userId UUID, richText TEXT, createdAt TIMESTAMP}. Controller: POST endpoint com validação JSR303. Service: CommentService.save(). Incluir parsing básico de @mentions no texto salvo.",
            "status": "done",
            "testStrategy": "Testar POST comment válido, rejeição sem task_id válido, persistência no banco PostgreSQL. Verificar constraints de tamanho rich_text.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar CommentEditor Frontend com TipTap",
            "description": "Criar componente CommentEditor usando TipTap/ProseMirror com suporte rich text e @mention autocomplete",
            "dependencies": [
              1
            ],
            "details": "Usar @tiptap/react + @tiptap/starter-kit. Extension custom Mention com autocomplete de membros projeto via API /projects/{id}/members. Debounce submit após 2s ou Ctrl+Enter. Sanitizar HTML output com DOMPurify.",
            "status": "pending",
            "testStrategy": "Testar rich text (bold, italic, list), @mention autocomplete funciona, submit envia JSON correto para backend. Verificar XSS prevention.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementar Parsing @Mentions e Notificações",
            "description": "Parsear @username do rich_text, mapear para user_id via ProjectMember e disparar notificações in-app",
            "dependencies": [
              1,
              2
            ],
            "details": "No CommentService.save(): regex /@([a-zA-Z0-9_-]+)/g → buscar ProjectMember por username → criar Notification entities → WebSocket 'new_notification' para user_ids mencionados. Integrar com Task 10 Notification system.",
            "status": "done",
            "testStrategy": "Comment '@joao' → Notification criada para joão → WebSocket received em outro browser. Testar mention inválido ignorado.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementar Upload GCP Storage com Signed URLs",
            "description": "Gerar signed URLs para upload direto GCP Storage e salvar URL no comment como anexo",
            "dependencies": [
              1,
              2
            ],
            "details": "Backend: POST /tasks/{id}/comments/upload-url → GoogleCloudStorage.generateSignedUrl(50MB, 15min). Frontend: CommentEditor upload button → fetch signed URL → upload direto → inserir <img src='gcp-url'> ou PDF preview. Limitar 50MB.",
            "status": "done",
            "testStrategy": "Upload 1MB/50MB sucesso, 51MB rejeitado. Imagem inline preview funciona. PDF thumbnail preview. Cleanup URLs expiradas.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implementar WebSocket Comments e Audit Logging",
            "description": "Real-time new_comment events via WebSocket + audit log completo para ações de comentários",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "WebSocket: 'new_comment' event com comment JSON para task subscribers. Frontend: useWebSocket subscribe task_id → append new comments UI. AOP @Aspect: log CREATE/UPDATE/DELETE comments com user_id de JWT, IP, old/new JSON. Integrar Task 10 audit system.",
            "status": "done",
            "testStrategy": "2 browsers: user1 posta comment → user2 vê real-time. Audit_log tem entrada CREATE com dados corretos. Testar DELETE comment logs.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 10,
        "title": "Sistema de Auditoria LGPD e Notificações In-App",
        "description": "Implementar audit_log completo para todas ações + notificações em tempo real com preferências usuário",
        "details": "AOP: @Aspect para loggar @Before/@After controllers (usuario_id de JWT, tabela, operacao CREATE/UPDATE/DELETE, dados_anteriores/novos JSON). Entity AuditLog com todos campos. Notificações: Entity Notification, WebSocket 'new_notification' por user_id. UI: NotificationBell com dropdown não-lidas.",
        "testStrategy": "Executar CRUD completo projeto/tarefa, verificar 100% ações em audit_log com IP/user_agent/timestamps corretos. Testar notificações real-time múltiplos browsers. LGPD: teste 'direito ao esquecimento' DELETE user apaga dados.",
        "priority": "medium",
        "dependencies": [
          "1",
          "2",
          "3",
          "4",
          "5",
          "6"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar Entidade AuditLog para LGPD",
            "description": "Criar entidade JPA AuditLog com todos campos necessários para auditoria completa de ações conforme LGPD.",
            "dependencies": [],
            "details": "@Entity AuditLog: id(UUID), usuario_id(UUID), tabela(String), operacao(Enum: CREATE/UPDATE/DELETE), dados_anteriores(JSONB), dados_novos(JSONB), ip_address(String), user_agent(String), timestamp(LocalDateTime), projeto_id(UUID). Adicionar índices em usuario_id, timestamp, tabela. Usar @PrePersist/@PreUpdate para auto-timestamps.",
            "status": "pending",
            "testStrategy": "Testar serialização JSONB com dados complexos. Verificar constraints unique e índices. Testar query findByUsuarioIdAndDataAfter."
          },
          {
            "id": 2,
            "title": "Desenvolver AOP Aspect para Logging Automático",
            "description": "Implementar @Aspect Spring AOP para interceptar @Before/@After controllers e loggar ações em AuditLog.",
            "dependencies": [
              1
            ],
            "details": "@Aspect com @Before/@After(\"execution(* com.exemplo.controller.*.*(..))\"). Extrair usuario_id de SecurityContext (JWT). Detectar operacao via HttpMethod/endpoint. Serializar request/response body para JSONB. Salvar via AuditLogService. Tratar exceções sem quebrar fluxo.",
            "status": "pending",
            "testStrategy": "Testar com MockMvc: POST/PUT/DELETE endpoints. Verificar 100% ações logadas com dados_anteriores/novos corretos. Testar sem JWT (deve falhar graciosamente)."
          },
          {
            "id": 3,
            "title": "Implementar Entidade Notification e Repositório",
            "description": "Criar entidade Notification com preferências usuário e repositório para gerenciamento.",
            "dependencies": [
              1
            ],
            "details": "@Entity Notification: id(UUID), usuario_id(UUID), titulo(String), mensagem(Text), lida(boolean default false), tipo(Enum: INFO/WARNING/ERROR), projeto_id(UUID), criado_em(LocalDateTime). Repositório com findByUsuarioIdAndLidaFalseOrderByCriadoEmDesc. Tabela preferencias por user: email(boolean), inapp(boolean), webpush(boolean).",
            "status": "pending",
            "testStrategy": "Testar CRUD notifications. Query não-lidas por user. Verificar defaults e ordenação temporal."
          },
          {
            "id": 4,
            "title": "Configurar WebSocket para Notificações Real-Time",
            "description": "Implementar WebSocket STOMP para enviar notificações 'new_notification' por user_id.",
            "dependencies": [
              3
            ],
            "details": "Configurar WebSocketMessageBrokerConfigurer com /ws como prefixo. Controller: @MessageMapping('/new_notification/{userId}'), @SendToUser('/topic/notifications'). Principal principal = SecurityContextHolder.getContext().getAuthentication(). Session por user_id. Integrar NotificationService para trigger.",
            "status": "pending",
            "testStrategy": "Testar múltiplos browsers logados diferentes users. Enviar notificação via POST, verificar real-time delivery. Testar disconnect/reconnect."
          },
          {
            "id": 5,
            "title": "Desenvolver UI NotificationBell com Dropdown",
            "description": "Implementar componente React NotificationBell com dropdown de notificações não-lidas e WebSocket listener.",
            "dependencies": [
              4
            ],
            "details": "Componente: Badge com contador não-lidas (useQuery). Dropdown lista com markAsRead onClick. useWebSocket hook para '/user/topic/notifications'. Refresh contador via useSWR. Toast para novas notificações. Mobile responsive com slide-down.",
            "status": "pending",
            "testStrategy": "Testar fluxo: nova notificação -> badge++, click dropdown -> mark read -> badge 0. Verificar WebSocket em múltiplas abas. Testar preferências user (inapp off não mostra)."
          }
        ]
      },
      {
        "id": 11,
        "title": "Dashboard Executivo com KPIs e Gantt Timeline",
        "description": "Implementar Dashboard com KPIs (projetos andamento, taxa conclusão, atrasos) e timeline Gantt visual",
        "details": "Backend: GET /api/v1/dashboard com agregações SQL (COUNT projetos por status, AVG completion rate). Frontend: Dashboard.tsx com Charts (Recharts), KPI cards, Gantt com react-gantt-timeline. Cores saúde: verde>90%, amarelo 70-90%, vermelho<70%. Lazy loading dados.",
        "testStrategy": "Criar dados teste 10 projetos variados statuses. Verificar KPIs matemáticos corretos. Responsive mobile. Performance: <2s load time first paint.",
        "priority": "medium",
        "dependencies": [
          "4",
          "6",
          "7"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and define dashboard API response and SQL aggregations",
            "description": "Design the /api/v1/dashboard response shape and implement SQL aggregation queries (COUNT by status, AVG completion rate, overdue counts) in the backend.",
            "dependencies": [],
            "details": "Define JSON schema for KPI cards and Gantt data (projects list with id, name, start_date, end_date, percent_complete, status, owner, dependencies). Implement SQL queries and/or views that compute: total projects by status (COUNT), average completion rate (AVG(percent_complete)), count of overdue projects (WHERE end_date < NOW() AND percent_complete < 100), and timeline data (start/end, percent, id). Ensure queries are efficient (use proper indexes on status, end_date, start_date) and return paginated or limited results for Gantt lazy loading. Add DTOs and mapping in the application layer to produce the final API shape.",
            "status": "pending",
            "testStrategy": "Unit tests for repository methods with in-memory DB or Testcontainers; verify SQL results for 10 seeded projects covering statuses and ranges; contract tests that API response matches defined JSON schema."
          },
          {
            "id": 2,
            "title": "Implement GET /api/v1/dashboard endpoint and backend service layer",
            "description": "Create controller, service/use-case and repository integration for the dashboard endpoint returning aggregated KPIs and timeline items.",
            "dependencies": [
              1
            ],
            "details": "Implement DashboardController with GET /api/v1/dashboard that accepts optional query params (startDate, endDate, limit, page) to support lazy loading. Implement DashboardService/DashboardUseCase that calls repository aggregation methods from subtask 1, composes KPI summary and timeline items, and applies health color logic (green >90, yellow 70-90, red <70) in the DTOs. Add caching layer (short TTL) or database-level optimizations to keep first-load <2s. Ensure JWT security and authorization checks are applied as with other endpoints.",
            "status": "pending",
            "testStrategy": "Integration tests with MockMvc or WebTestClient: call endpoint with seeded data and assert KPI numeric correctness and health color mapping; performance test to assert response time <2s for typical dataset."
          },
          {
            "id": 3,
            "title": "Create Dashboard UI layout and KPI cards in Dashboard.tsx",
            "description": "Implement the frontend Dashboard.tsx skeleton with KPI cards, layout, and lazy data fetching for KPI summary using existing auth/axios utilities.",
            "dependencies": [
              2
            ],
            "details": "Design responsive layout with KPI cards for: projects in progress, average completion rate, overdue projects and other chosen KPIs. Use existing axios instance with JWT interceptor to call GET /api/v1/dashboard (using query params for lazy load) and implement client-side loading and error states. Apply health color rules to KPI cards (green>90%, yellow 70-90%, red<70%) and ensure accessible color contrasts. Implement unit tests for small presentational components and responsive breakpoints for mobile/tablet/desktop.",
            "status": "pending",
            "testStrategy": "Frontend unit tests (Jest + React Testing Library) asserting rendered KPI values and color class based on mocked API responses; visual snapshot tests for Desktop and Mobile widths."
          },
          {
            "id": 4,
            "title": "Implement Charts with Recharts and KPIs visualizations",
            "description": "Add charts to Dashboard.tsx using Recharts to visualize KPI trends and distribution (status pie/stacked bar, completion rate trend), with lazy loading and interaction.",
            "dependencies": [
              3
            ],
            "details": "Integrate Recharts components (PieChart or BarChart for projects by status, LineChart for completion rate over time). Fetch required chart series via the dashboard endpoint or ancillary endpoints if needed. Add tooltips, legends, and responsive wrappers. Ensure charts render incremental data when user scrolls/requests more timeline entries (lazy load). Optimize rendering by memoizing datasets and using lightweight components to preserve smoothness with dozens of items.",
            "status": "pending",
            "testStrategy": "Component tests verifying charts render expected series when given API data; manual E2E or Playwright test to confirm charts load and remain interactive under simulated slow network and mobile viewport."
          },
          {
            "id": 5,
            "title": "Integrate react-gantt-timeline Gantt and end-to-end dashboard integration",
            "description": "Implement Gantt timeline with react-gantt-timeline, wire it to the backend timeline data, support lazy-loading, tooltips, and draggable interactions if required, and finalize end-to-end integration with KPI components.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Add Gantt component to Dashboard.tsx using react-gantt-timeline. Map backend timeline items to Gantt tasks (id, start, end, name, percentComplete, color based on health). Implement lazy loading/pagination for tasks (load initial window, fetch more on scroll or timeline range change). Support basic interactions: task hover tooltip showing project info and KPIs, and optional read-only drag if business allows (otherwise disable). Handle error/loading states and ensure accessibility. Update routing and navigation to include Dashboard and guard with auth. Run performance profiling to meet <2s first paint requirement.",
            "status": "pending",
            "testStrategy": "E2E tests (Playwright) that seed 10 varied projects and verify Gantt renders correct bars, percent labels and color coding; verify lazy-load fetches more tasks and KPI cards stay consistent; responsive tests and basic interaction tests (hover/tooltips)."
          }
        ]
      },
      {
        "id": 12,
        "title": "Dockerização, CI/CD GitHub Actions e Deploy GCP GKE",
        "description": "Containerizar app backend/frontend e configurar pipeline CI/CD para deploy automatizado em Google Kubernetes Engine",
        "details": "Backend Dockerfile multi-stage Java 17. Frontend Dockerfile Node 20 build + nginx serve. GitHub Actions: build-test-docker-push-deploy-gke.yml com terraform apply. Kubernetes manifests: deployment, service, ingress com Cloud Armor. Helm charts para values.yaml. Secrets GCP Workload Identity.",
        "testStrategy": "Executar pipeline end-to-end com GitHub PR. Verificar deploy GKE: kubectl get pods/services. Load test 1000 concurrent users com Artillery. Uptime 99.9% monitoramento Cloud Monitoring.",
        "priority": "high",
        "dependencies": [
          "1",
          "3",
          "4",
          "6",
          "7",
          "8"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create and validate multi-stage Dockerfile for backend (Java 17)",
            "description": "Implement a production-ready multi-stage Dockerfile for the Java 17 backend and validate local image build and runtime behavior.",
            "dependencies": [],
            "details": "Create Dockerfile using multi-stage build: build stage using Maven/Gradle with Java 17 to produce optimized jar, final stage using a minimal JRE (e.g., Eclipse Temurin jdk:jre or distroless) with non-root user, proper JVM options, healthcheck, and layered cache-friendly instructions. Add .dockerignore, build arguments (APP_VERSION, MAVEN_OPTS), and labels. Implement image signing/scan step (optional). Verify that the container starts, exposes correct port, and reads configuration from environment variables (spring profiles, datasource, JWT secret).",
            "status": "pending",
            "testStrategy": "Build image locally (docker build) and run container; execute integration smoke tests against /actuator/health and main API endpoints; verify logs, non-root user, and environment variable overrides. Use a lightweight container scan (e.g., trivy) to assert no critical vulnerabilities.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create and validate frontend Dockerfile (Node 20 build + nginx serve)",
            "description": "Implement a Dockerfile that builds the frontend with Node 20 and serves static files with nginx in a production-optimized image.",
            "dependencies": [
              1
            ],
            "details": "Create two-stage Dockerfile: build stage using Node 20 to run npm install and npm run build, and final stage using nginx:stable-alpine to copy built assets into nginx html path and include custom nginx.conf for gzip, caching and CORS. Include environment substitution mechanism for runtime configuration (envsubst or small entrypoint) to inject API base URL. Add .dockerignore and image labels. Ensure small final image and proper cache headers for static assets.",
            "status": "pending",
            "testStrategy": "Build image locally and run container; verify static site served (HTTP 200), correct caching headers, runtime configuration substitution, and that production build matches expected bundle output. Run lighthouse/basic performance check in CI.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement GitHub Actions CI pipeline: build, test, image push, terraform apply",
            "description": "Create GitHub Actions workflow (build-test-docker-push-deploy-gke.yml) to run tests, build images, push to GCR/Artifact Registry, and run Terraform apply for infrastructure changes.",
            "dependencies": [
              1,
              2
            ],
            "details": "Write a composite workflow that runs on push to main and PRs: steps for checkout, cache dependencies, run backend unit/integration tests, run frontend tests and build, build multi-arch container images (or standard) for backend and frontend, tag images with commit SHA and semantic tag, authenticate to Google Cloud (use Workload Identity/GITHUB_ACTIONS with OIDC), push images to Artifact Registry/GCR, run terraform init/plan and terraform apply (auto-approve only for main), and trigger Helm/Kustomize deploy to GKE. Add secrets/config mapping via GitHub Secrets and enforce required checks. Include rollback strategy and image immutability tags.",
            "status": "pending",
            "testStrategy": "Run workflow on feature branch and PR: verify tests pass, images pushed to registry with expected tags, terraform plan outputs expected changes, and no creds are stored in secrets. Use dry-run terraform apply in PR and full apply on merge to main. Validate OIDC-based auth by confirming no long-lived service account keys are used.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Prepare Kubernetes manifests and Helm chart for GKE deploy (Deployment, Service, Ingress, Cloud Armor)",
            "description": "Create parametrized Kubernetes manifests and a Helm chart (values.yaml) to deploy backend and frontend on GKE, including Service, Deployment, Ingress with Cloud Armor integration and necessary RBAC/ServiceAccount for Workload Identity.",
            "dependencies": [
              3
            ],
            "details": "Author Helm chart(s) that include Deployments (readiness/liveness probes), Services (ClusterIP or NodePort as needed), HorizontalPodAutoscaler config, Ingress spec compatible with GKE Ingress (enable BackendConfig annotation for Cloud Armor), ConfigMap/Secret templates (for JWT keys, DB), and ServiceAccount annotated for Workload Identity binding. Provide values.yaml with image repository/tags, resource requests/limits, replica counts, probe paths, and ingress host rules. Add manifest for network/Cloud Armor configuration (via BackendConfig or Terraform-managed resource) and ensure TLS secret reference. Include notes for Kubernetes namespace creation and RBAC roles if required.",
            "status": "pending",
            "testStrategy": "Run helm lint and template with multiple values files (staging, prod). Deploy to a non-production GKE cluster via CI: helm install/upgrade and validate pods ready, services present, ingress created, and Cloud Armor policy attached. Verify liveness/readiness probes and autoscaling by scaling replicas and hitting endpoints.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Configure GCP authentication, Workload Identity and end-to-end CI/CD deployment validation",
            "description": "Configure GCP IAM, Workload Identity, Artifact Registry permissions and validate end-to-end automated deployment from GitHub to GKE with monitoring and smoke tests.",
            "dependencies": [
              3,
              4
            ],
            "details": "Create Terraform or IaC steps (called by pipeline) to provision GKE cluster (node pools, autopilot/standard), Artifact Registry, Service Account and IAM bindings, Workload Identity pool and provider for GitHub OIDC, and Cloud Monitoring/Logging setup. Assign minimum required roles for pushing images and deploying to GKE. Ensure Kubernetes ServiceAccount is bound to GCP Service Account via Workload Identity annotation. Add secrets handling (Kubernetes Secret or SecretManager integration). Update GitHub Actions to use OIDC to impersonate the GCP SA. Document manual steps for initial bootstrap if needed.",
            "status": "pending",
            "testStrategy": "Trigger pipeline from PR to main and verify: images push, terraform apply provisions resources, helm deploy succeeds, kubectl get pods/services show running workloads, ingress exposes app with TLS, Cloud Armor policy active. Run end-to-end smoke tests and a controlled load test (e.g., Artillery 1000 concurrent users) in a staging environment and verify Cloud Monitoring alerts and 99.9% uptime criteria are met.",
            "parentId": "undefined"
          }
        ]
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-12-14T00:42:20.911Z",
      "taskCount": 12,
      "completedCount": 6,
      "tags": [
        "master"
      ],
      "created": "2025-12-14T00:42:20.947Z",
      "description": "Tasks for master context"
    }
  }
}